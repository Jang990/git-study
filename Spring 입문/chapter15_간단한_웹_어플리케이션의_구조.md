# Spring 5 입문 Chapter15 간단한 웹 어플리케이션의 구조

## 간단한 웹 어플리케이션의 구성 요소

간단한 웹 어플리케이션을 개발할 때 사용하는 전형적인 구조는 다음 요소를 포함한다.

* 프론트 서블릿
* 컨트롤러 + 뷰
* 서비스
* DAO

<br>

**프론트 서블릿**은 웹 브라우저의 모든 요청을 받는 창구 역할을 한다. 프론트 서블릿은 요청을 분석해서 알맞은 컨트롤러에 전달한다. 스프링 MVC에서는 `DispatcherServlet`이 프론트 서블릿의 역할을 수행한다.

DispatcherServlet -> 컨트롤러 -> 서비스 -> DAO

<br>

**컨트롤러**는 실제 웹 브라우저의 요청을 처리한다. 지금까지 구현했던 스프링 컨트롤러가 이에 해당한다. 컨트롤러는 클라이언트(브라우저)의 요청을 처리하기 위해 알맞은 기능을 실행하고 그 결과를 뷰에 전달한다. 컨트롤러의 주요 역할은 다음과 같다

* 클라이언트가 요구한 기능 실행
* 응답 결과를 생성하는데 필요한 모델 생성
* 응답 결과를 생성할 뷰 선택

컨트롤러는 어플리케이션이 제공하는 기능과 사용자 요청을 연결하는 매개체로서 **기능 제공을 위한 로직을 직접 수행하지 않는다.** 대신 해당 로직을 제공하는 서비스에 그 처리를 위임한다.

<br>

**서비스**는 **기능의 로직을 구현**한다. 사용자에게 비밀번호 변경 기능을 제공하려면 수정 폼을 제공하고, 로그인 여부를 확인하고, 실제로 비밀번호를 변경해야 한다. 이 중에서 핵심 로직은 비밀번호를 변경하는 것이다. 

서비스는 DB 연동이 필요하면 DAO를 사용한다. **DAO**는 Data Access Object의 약자로서 DB와 웹 **어플리케이션 간에 데이터를 이동시켜주는 역할**을 맡는다. DAO를 통해서 DB에 데이터를 추가하거나 DB에서 데이터를 읽어온다.

부가적인 로직이 없는 경우에는 컨트롤러에서 직접 DAO를 사용하기도 한다.

<br>
<br>

## 서비스의 구현

서비스의 구현에 대해 좀 더 내용을 풀어보자. 서비스는 핵심이 되는 기능의 로직을 제공한다고 했다. 예를 들어 비밀번호 변경 기능은 다음 로직을 서비스에서 수행한다.

* DB에서 비밀번호를 변경할 회원 데이터 구하기
* 존재하지 않으면 익셉션 발생
* 회원 데이터의 비밀번호 변경
* DB 반영

이런 로직들은 한 번의 과정으로 끝나기보다는 위 예제처럼 몇 단계의 과정을 거치고, 모든 과정을 성공적으로 진행했을 때 완료해야 한다. 이런 이유로 서비스 메서드를 트랜잭션 범위에서 실행한다.

```java
@Transaction
public void changePwd(String email, String oldPwd, String newPwd) {
    Member member = memberDao.selectByEmail(email);
    if(member == null) 
        throw new MemberNotFoundException();
    
    member.changePassword(oldPwd, new Pwd);
    memberDao.update(member);
}
```

<br>

서비스를 구현할 때 서비스가 제공할 기능의 개수는 몇 개가 적당할까?

필자는 기능별로 서비스 클래스를 작성하는 것을 선호한다. 그 이유는 한 클래스의 코드 길이를 일정 수준 안에서 유지할 수 있기 때문이다. 클래스의 코드 길이가 길어지면 이후에 기존 코드를 수정하거나 기능을 확장하기 어려울 때가 많다. 기능마다 서비스 클래스를 따로 만들면 이런 문제가 발생할 가능성을 줄일 수 있다.

<br>

서비스 메서드는 기능을 실행한 후 결과를 알려주어야 한다. 결과는 크게 두 가지 방식으로 알려준다.

* 리턴 값을 이용한 정상 결과
* 익셉션을 이용한 비정상 결과

<br>
<br>

## 컨트롤러에서 DAO 접근

서비스 메서드에서 어떤 로직도 수행하지 않고 단순히 DAO 메서드만 호출하는 코드도 있다. 예를 들어 회원 데이터 조회를 위한 서비스 메서드를 다음과 같이 구현하곤 한다

```java
//서비스 부분
public class MemberService {
    ...
    public membergetMember(Long id) {
        return memberDao.selectById(id);
    }
}
```
```java
...
//컨트롤러부분
@RequestMapping("member/detail/{id}")
public String detail(@PathValue("id") Long id, Model model) {
    Member member = memberService.getMember(id);
    ...
}
```

이 코드에서 `selectByEmail()` 메서드만 실행할 뿐 추가 로직은 없다. 컨트롤러 클래스는 이 서비스 메서드를 이용해서 회원 정보를 구하게 된다. 필자는 이 경우 컨트롤러는 서비스를 사용해야 한다는 압박에서 벗어나 다음과 같이 DAO에 직접 접근해도 큰 틀에서 웹 어플리케이션의 계층 구조는 유지된다고 본다.

```java
//컨트롤러부분
@RequestMapping("member/detail/{id}")
public String detail(@PathValue("id") Long id, Model model) {
    Member member = memberDao.selectById(id);
    ...
}
```

컨트롤러에서 서비스 계층을 거치지 않고 바로 데이터 접근 계층의 DAO를 사용하는 방식은 개발자마다 호불호가 갈린다. 어떤 방식이 좋다는 식의 정답은 없으니 독자 나름대로 서비스의 역할과 DAO의 역할을 정의해나가면서 선호하는 방식을 정립하길 바란다.

<br>
<br>

## 패키지 구성

패키지 구성에는 사실 정답이 없다. 중요한 점은 팀 구성원 모두가 동일한 규칙에 따라 일관되게 패키지를 구성해야 한다는 것이다. 개발자에 따라 패키지를 구성하는 방식이 서로 다르면 코드를 유지보수할 때 불필요하게 시간을 낭비하게 된다. 예를 들면 당연히 존재할 거라고 생각한 패키지가 아닌 예상 밖의 패키지에 위치한 클래스를 찾느라 시간을 허비할 수 있다.

<br>
<br>

컨트롤러-서비스-DAO 구조는 간단한 웹 어플리케이션을 개발하기에는 무리가 없다. 문제는 어플리케이션이 기능이 많아지고 로직이 추가되 시작할 때 발생하낟. 로직이 복잡해지면 컨트롤러-서비스-DAO 구조의 코드도 함께 복잡해지는 경향이 있다.

웹 어플리케이션이 복잡해지고 커지면서 코드도 함께 복잡해지는 문제를 완화하는 방법 중 하나는 도메인 주도 설계를 적용하는 것이다. 도메인 주도 설계는 컨트롤러-서비스-DAO구조 대신 UI-서비스-도메인-인프라의 네 영역으로 어플리케이션을 구성한다.

여기서 UI는 컨트롤러 영역에 대응하고 인프라는 DAO 영역에 대응한다. 중요한 점은 주요한 도메인 모델과 업무 로직이 서비스 영역이 아닌 도메인 영역에 위치한다는 것이다. 또한 도메인 여역은 정해진 패턴에 따라 모델을 구현한다. 이를 통해 업무가 복잡해져도 일정 수준의 복잡도로 코드를 유지할 수 있도록 해준다. 

도메인 주도 설계에 대한 내용이 궁금한 독자는 관련 서적을 참고하자


<br>
<br>

### 책 이외의 내용
<hr>

## 도메인(Domain)이란

온라인서점 사이트에서 책을 조회하고 구매한다고 가정하자. 개발자 입장에서 온라인서점은 구현해야할 소프트웨어의 대상이 된다. 온라인서점 소프트웨어는 상품의 조회, 구매, 결제등의 기능을 제공해야한다. 이때 온라인 서점은 소프트웨어로 해결하고자하는 문제 영역, 즉 도메인(domain)에 해당된다.

한 도메인은 다시 하위 도메인으로 나눌 수 있다. 예를 들어 '온라인 서점' 도메인은 다시 주문, 결제, 배송같은 하위 도메인을 가진다. 

[출처]https://doing7.tistory.com/79

이전 챕터에서 사용한 `Person`과 같은 클래스들이 도메인이라 할 수 있는 것 같다.

```java
public class Person {
	private String name;
	private int age;
	private Pet pet;
    ...	
}
```

<br>
<br>


