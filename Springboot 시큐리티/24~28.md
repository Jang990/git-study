# 24~28강

## 24

시큐리티 로그인 관련 `UserDetails`와 `UserDetailsService`를 만듦.

<br>

원래 기본적으로 시큐리티는 'http://localhost:8080/login' URL로 로그인을 진행한다. 하지만 시큐리티 설정에서 `http.formLogin().disable();` 이렇게 설정했기 때문에 로그인이 진행되지 않는다.

그렇기 때문에 직접 `UserDetailsService`를 해주는 필터를 하나 만들어야 한다.

스프링 시큐리티에 `UsernamePasswordAuthenticationFilter`가 있다. '/login' 요청해서 username,password 전송(post)하면 이 `UsernamePasswordAuthenticationFilter`가 동작한다. 이 필터는 `AuthenticationManager`를 통해서 로그인을 진행하기 때문에 필터에 `AuthenticationManager`를 넘겨주어야 한다.



```java
//스프링 시큐리티 설정 부분
http.addFilter(corsConfig)
	.addFilter(new JwtAuthenticationFilter(authenticationManager()));
    //authenticationManager()은 시큐리티 설정에서 제공한다.
...
```

```java
import org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter;

@RequiredArgsConstructor //자동으로 멤버 변수를 받는 생성자를 만듦
public class JwtAuthenticationFilter extends UsernamePasswordAuthenticationFilter {
	private final AuthenticationManager authenticationManager;
}
```

`UsernamePasswordAuthenticationFilter`에서 로그인을 시도하는 메서드는 `attemptAuthentication()`이다. 이 메서드는 '/login' 요청을 하면 로그인 시도를 위해서 실행되는 메서드이다.

<br> 

정리하자면 기본적으로 '/login' 요청이오면 `UsernamePasswordAuthenticationFilter`가 낚아채서 `attemptAuthentication()` 메서드가 자동으로 실행된다. 그러므로 `attemptAuthentication()` 메서드에서 id와 pw를 DB에서 확인하면 될 것이다.

여기서 생성자로 넘겨받은 `authenticationManager`로 로그인 시도를 하면 `PrincipalDetailsService`가 호출이 되면서 `loadUserByUsername()`메서드가 자동으로 실행된다.

그러면 `PrincipalDetails`를 세션에 담고  JWT 토큰을 만들어서 응답해주면 된다.

<br>

여기서 세션에 담는 이유는 권한관리를 위해서 담는 것이다. 권한 관리가 필요없다면 세션에 담을 필요가 없이 JWT를 만들어서 응답해주면 끝이다. 

<br>

아래는 세션을 사용하는 이유에 대한 영상 댓글이니 참고하자.

```
우리가 security의 formlogin을 사용하지 않는데
UsernamePasswordAuthenticationFilter을 상속받은 녀석을 강제로 호출하여 AuthenticationManager을 호출 -> 시큐리티에게 로그인을 위임하는 이유는
시큐리티에게 권한 관리를 맡기기 위해서이다.


만약 JWT의 특성을 완벽히 구현하기 위해서, 즉 세션없는 stateful + 권한을 완벽히 구현하기 위해서는 권한 관리 로직을 따로 구현해야 한다.

그렇게 한다면 로그인을 스프링 시큐리티에게 위임하지 않기 때문에, (세션을 사용하지 않기 때문에)
UserDetails, UserDetailsService를 구현하지 않아도 되고
그렇다면 로그인 로직까지 따로 구현해야 한다.
그러므로 완전히 세션을 이용하지 않으려면
JWT + 로그인 + 권한관리 로직이 따로 들어가야한다.
```