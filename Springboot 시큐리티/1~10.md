# 1~10강

알게된 내용 정리

## 배경지식
JPA 얕은 이해, 스프링 입문 이해

메타코딩, Springboot - 나만의 블로그 만들기 48,49,50강
https://www.youtube.com/watch?v=zi1l3lYJRL4&list=PL93mKxaRDidECgjOBjPgI3Dyo8ka6Ilqm&index=50

그냥 한번만 훑어봄

## 48강

## 1강

### Spring Dev tool
파일이 변경될 때마다 서버 재시작

<br>

### `@GetMapping`
```java
@GetMapping({"", "/"})
public String index() {
	return "index";
}
```
위 코드처럼 "localhost:8080/", "localhost:8080" url을 받을 수 있다.

<br>

### mustache(머스테치)
mustache는 스프링에서 권장하는 간단한 템플릿 엔진이다.

간단하기 때문에 인터넷에 검색해보고 관련 글만 읽고 바로 사용해도 될 정도이다.

머스테치의 기본폴더는 `src/main/resources/` 이다.

뷰 리졸버 설정만 `prefix: /templates/`, `suffix: .mustache`로 설정해주면 된다.(이 설정은 생략가능하다.) 

<br>

### WebMvcConfig.java 파일 생성
현재 설정에서 index.html 파일을 templates 폴더에 만들면 스프링에서는 `src/main/resources/templates/index.mustache` 를 찾는다.

그래서 다음과 같은 설정 파일을 따로 만든다.
```java
@Configuration
public class WebMvcConfig implements WebMvcConfigurer{
	@Override
	public void configureViewResolvers(ViewResolverRegistry registry) {
		MustacheViewResolver resolver = new MustacheViewResolver();
		resolver.setCharset("UTF-8"); // 내가 만드는 뷰의 인코딩은 기본적으로 UTF-8
		resolver.setContentType("text/html; charset=UTF-8"); // 내가 너한테 던지는 파일은 html파일에 UTF-8
		resolver.setPrefix("classpath:/templates/"); // classpath: 까지가 너의 프로젝트 경로
		resolver.setSuffix(".html");
		
		registry.viewResolver(resolver); // 생성한 뷰 리졸버 등록
	}
}
```

<br>

### 시큐리티
스프링 부트 시큐리티 의존성을 설정하게 되면 우리 페이지로 가는 모든 주소가 막혀서 인증이 필요한 서버가 된다. 비밀번호는 서버 실행 콘솔창이 `Using generated security password: ...` 이렇게 나오고 아이디는 'user'라고 입력하면 된다.

이 강의는 시큐리티에 아주 기본적인것을 다룬다.

<br>
<br>

## 2강

### 시큐리티 로그아웃
`localhost:8080/logout`으로 스프링 시큐리티 로그아웃 가능
`localhost:8080/logout`으로 스프링 시큐리티 로그인 가능

위 주소를 스프링 시큐리티가 가지고 있기 때문에 `@GetMapping("/login")`로 만들어도 스프링 시큐리티가 낚아챈다. 나중에 따로 설정을 한다.

### @EnableWebSecurity와 시큐리티 설정파일(SecurityConfig.class)
`localhost:8080/user`는 로그인한 사람만, `localhost:8080/manager`는 로그인한 사람중 manager 권한이 있는사람만 접근하게 하고 싶다. 

`SecurityConfig.class` 설정 파일을 작성한다. 이 설정파일에 `@EnableWebSecurity` 어노테이션을 추가해야 한다. 이 어노테이션은 스프링 시큐리티 필터(`SecurityConfig.class`)가 스프링 필터 체인에 등록이 된다. 

다음 소스코드를 한번 읽어보라

```java
@Configuration
@EnableWebSecurity // 스프링 시큐리티 필터가 스프링 필터체인에 등록이 된다.
public class SecurityConfig extends WebSecurityConfigurerAdapter {
	
	@Override
	protected void configure(HttpSecurity http) throws Exception {
		http.csrf().disable();
		http.authorizeHttpRequests() // 어떤 request가 들어온다면.
			.antMatchers("/user/**").authenticated() // /user/** 이런주소로 들어오면 인증이 필요해
			.antMatchers("/manager/**").hasRole("ROLE_ADMIN or ROLE_MANAGER") // /manager/** 이런 주소로 들어오면 인증뿐만 아니라 "ROLE_ADMIN or ROLE_MANAGER" 권한이 있는 사람만 들어오게 할거야 
			.antMatchers("/admin/**").hasRole("ROLE_ADMIN")
			.anyRequest().permitAll(); // 다른 모든 request는 권한 허용.
	}
}
```

이렇게 설정을 한 후 'localhost:8080/user'에 접근하면 인증이 없어서, 'localhost:8080/manager', 'localhost:8080/admin'에 접근하면 권한이 없어서 뜨는 403 에러가 뜬다.

또한 이 파일을 만든 후 적용시키면 'localhost:8080/login' 페이지를 스프링 시큐리티에서 낚아채지 않는다.

<br>

### 권한 없는 사용자를 로그인페이지로 이동시키기

위의 상황에서 접근 권한이 없는 사용자가 'localhost:8080/user'에 접근해서 에러페이지를 보는것이 아니라 로그인페이지로 이동시키고 싶다면 다음과 같은 코드를 추가해주면 된다.

```java
@Override
	protected void configure(HttpSecurity http) throws Exception {
		http.csrf().disable();
		http.authorizeHttpRequests()
			.antMatchers("/user/**").authenticated()
            ... // 생략
            /* 아래가 추가된 코드들*/ 
			.and()
			.formLogin()
			.loginPage("/login");
	}
```
위의 코드를 추가해준다면 'localhost:8080/user', 'localhost:8080/manager', 'localhost:8080/admin'에 권한없이 접근한다면 에러페이지가 나오는 것이 아닌 ' localhost:8080/login' 페이지로 이동한다.

<br>
<br>

## 3강

모델을 작성하고 html파일들을 작성함. 기본적으로 스프링 웹을 만들때 작성하는 것들...

<br>

### JPA Repository
`@Repository`라는 어노테이션 없이 빈으로 등록이 된다. 이유는 `JpaRepository`를 상속했기 때문이다.
```java
public interface UserRepository extends JpaRepository<User, Integer>{
	...
}
```

<br>

### 비밀번호 암호화
```java
@PostMapping("/join")
public @ResponseBody String join(User user) {
	System.out.println(user);
	user.setRole("ROLE_USER");
	userRepository.save(user);
	return "join";
}
```
이렇게 작성하면 로그인은 잘 진행되나 이렇게 하면 비밀번호가 그대로 저장되기 때문에 시큐리티로 로그인 할 수 없다. 패스워드를 암호화해야 시큐리티로 로그인이 가능하다.

<br>

```java
public class SecurityConfig extends WebSecurityConfigurerAdapter {
	
	@Bean
	public BCryptPasswordEncoder encodePwd() {
		return new BCryptPasswordEncoder();
	}
	
	@Override
	protected void configure(HttpSecurity http) throws Exception {
		...
	}
}
```

```java
@Autowired
private BCryptPasswordEncoder bCryptPasswordEncoder;

...

@PostMapping("/join")
public @ResponseBody String join(User user) {
	System.out.println(user);
	user.setRole("ROLE_USER");		
	String rawPassword = user.getPassword();
	String encPassword = bCryptPasswordEncoder.encode(rawPassword);
	user.setPassword(encPassword);
	userRepository.save(user);
	
	return "join";
}
```

강의에서는 먼저 코드와 같이 시큐리티 설정파일에서 `BCryptPasswordEncoder`를 빈으로 등록하고 `@Autowired`로 주입받아 암호화를 진행했다.

<br>
<br>




<br>

