# 22년 08월 15일

<br>

## Hibernate MultipleBagFetchException 오류

### 오류 설명
```java
@NamedEntityGraphs({
	@NamedEntityGraph(
			name = "all-detail-data",
			attributeNodes = {
					@NamedAttributeNode(value = "lectureList"),
					@NamedAttributeNode(value = "noticeList"),
					@NamedAttributeNode(value = "taskList"),
			},
			subgraphs = { @NamedSubgraph(
					name = "lecture-detail",
					attributeNodes = { @NamedAttributeNode("lectures") } 
				)
			}
	),
})
@Entity
@Data
@NoArgsConstructor
public class SubjectInfo {
	@Id
	private String subjectId;
	...
	
	@OneToMany(mappedBy = "subjectInfo")
	private List<WeekInfo> lectureList;
	@OneToMany(mappedBy = "subjectInfo")
	private List<TaskInfo> taskList;
	@OneToMany(mappedBy = "subjectInfo")
	private List<NoticeInfo> noticeList;
	...
}
```

위의 코드같이 JPA의 N + 1 문제를 해결하기 위해 세 자식의 데이터를 가져오는 "all-detail-data" `NamedEntityGraphs`를 사용하다 Hibernate MultipleBagFetchException 오류가 발생했다. 오류내용은 다음과 같다.

```console
org.springframework.dao.InvalidDataAccessApiUsageException: org.hibernate.loader.MultipleBagFetchException: cannot simultaneously fetch multiple bags: [com.esummary.elearning.entity.subject.SubjectInfo.noticeList, com.esummary.elearning.entity.subject.SubjectInfo.taskList, com.esummary.elearning.entity.subject.SubjectInfo.lectureList]; nested exception is java.lang.IllegalArgumentException: org.hibernate.loader.MultipleBagFetchException: cannot simultaneously fetch multiple bags: [com.esummary.elearning.entity.subject.SubjectInfo.noticeList, com.esummary.elearning.entity.subject.SubjectInfo.taskList, com.esummary.elearning.entity.subject.SubjectInfo.lectureList]
```
1:N 관계의 자식 테이블 여러곳에 Fetch Join을 사용하면 MultipleBagFetchException 에러가 발생한다고 한다.

<br>
<br>

### 해결을 위한 배경 지식

JPA에서 Hibernate를 구현체로 사용할 때, List 자료형은 Bag이라는 자료형으로 변환이 된다고 한다. 이 Bag에는 치명적인 단점이 있다. 예를들어 userA가 작성한 글 제목이 "ABC"라는 글을 삭제하려 할 때, 

```sql
-- userA가 작성한 글 전부 삭제
delete from userPost where userName = "userA"; 
-- 이외의 값을 다시 insert
insert into userPost(userName, postTitle) values("userA", "ABA");
insert into userPost(userName, postTitle) values("userA", "ABB");
insert into userPost(userName, postTitle) values("userA", "ABD");
```

이런식으로 작성자가 userA인 글을 모두 삭제한 후 ABC가 아닌 나머지 값을 다시 insert 하는 식으로 쿼리가 실행된다.

Bag 자료형을 사용하면 delete & update 를 실행할 때 delete All & re-insert 방식으로 구현이 된다는 것이다. 이는 프로그램 성능에는 치명적일 수 있다. 이런 문제를 피하기 위해 Set 자료형을 사용하면 Hibernate가 Bag 자료형을 사용하지 않고 문제를 해결할 수 있다고 한다. 

출처: https://chosh95.tistory.com/502

<br>
<br>

### 해결법

`List` 형식을 `Set`으로 바꿔주면 해결이 된다.
```java
...
@Entity
@Data
@NoArgsConstructor
public class SubjectInfo {
	...
	
	@OneToMany(mappedBy = "subjectInfo")
	private Set<WeekInfo> lectureList;
	@OneToMany(mappedBy = "subjectInfo")
	private Set<TaskInfo> taskList;
	@OneToMany(mappedBy = "subjectInfo")
	private Set<NoticeInfo> noticeList;
	...
}
```
만약 `HashSet` 자료형은 순서를 무시하기 때문에, 순서별로 정렬을 원한다면 `LinkedHashSet`를 사용하고 `@OrderBy` 어노테이션을 적용하면 정렬 문제도 해결될 것이다.

JPA를 쓸 때는 `Set` 자료형을 쓰는게 맞는 것 같다.
<br>
<br>

### 참고

하이버네이트는 Set에 @OrderBy를 적용해서 결과를 조회하면 순서를 유지하기 위해 HashSet 대신 LinkedHashSet을 내부에서 사용한다.


