package adapterpattern;

import adapterpattern.adapter.TurkeyAdapter;
import adapterpattern.duck.Duck;
import adapterpattern.duck.MallaradDuck;
import adapterpattern.turkey.WildTurkey;

public class Main {
	/*
	 *  챕터 7 - 1
	 * 
	 * 미국에서 쓰는 110v 콘센트(벽에 붙어 있는 전기를 제공하는 곳)와
	 * 우리나라에서 쓰는 220v 콘센트를 생각해봐라.
	 * 두 콘센트는 호환이 되지 않으나
	 * 콘센트 어댑터를 사용하면 각자의 플러그(꽂는 것)로도 다른 나라에 콘센트를 이용할 수 있을 것이다.
	 * 어댑터 패턴은 그런 패턴이다.
	 * 
	 *  어댑터 패턴(Adapter Pattern)
	 * 한 클래스의 인터페이스를 클라이언트에서 사용하고자 하는 다른 인터페이스로 변환합니다.
	 * 어댑터를 이용하면 인터페이스 호환성 문제 때문에 같이 쓸 수 없는 클래스들을 연결해서 쓸 수 있습니다.
	 * 
	 * 어댑터 패턴은 클라이언트를 특정 구현이 아닌 인터페이스에 연결 시킨다.
	 * 인터페이스를 기주으로 코딩을 했기 때문에 타겟 인터페이스만 제대로 지킨다면 나중에 다른 구현을 추가하는 것도 가능하다.
	 * 
	 * 어댑터에는 두 종류가 있다. 
	 * 하나는 객체 어댑터, 다른 하나는 클래스 어댑터.
	 * 여기서 배우는 것은 객체 어댑터이다.
	 * 클래스 어댑터는 다중 상속이 필요하다. 즉 자바에서는 사용이 불가능하다.
	 * 예를 들어 어댑터에서 Duck와 Turkey를 둘 다 상속받는다.
	 * 
	 * 데코레이터 패턴과 어댑터 패턴의 차이점(290p)
	 */
	
	public static void main(String[] args) {
		MallaradDuck duck = new MallaradDuck();
		WildTurkey turkey = new WildTurkey();
		Duck turkeyAdapter = new TurkeyAdapter(turkey);
		
		System.out.println("오리의 행동");
		duck.quack(); duck.fly();
		System.out.println();
		System.out.println();
		System.out.println("칠면조의 행동");
		turkey.gobble(); turkey.fly();
		System.out.println();
		System.out.println();
		System.out.println("어댑터");
		turkeyAdapter.quack(); turkeyAdapter.fly();
		
		/*
		 *  예제는 아주 단순한데 엄청 큰 인터페이스에 적용하면 할 일이 정말 많아질 것 같아요
		 * 맞는 말이다. 인터페이스의 크기에 비례해서 복잡해진다. 하지만 다른 대안이 있는가?
		 * 클라이언트 호출 부분을 새로운 인터페이스에 맞춰서 고치려면 상당히 여러 부분을 따져봐야 할 것이고,
		 * 코드도 엄청나게 많이 고쳐야 할 것이다. 
		 * 그냥 모든 변경 사항을 캡슐화 시킨 클래스 한 개만 제공하는 방법이 더 낫지 않을까?
		 * 
		 *  한 쪽 업체에서는 자신들의 인터페이스를 제공하고 다른 업체에서는 다른 인터페이스를 제공하는데 이 둘을 합칠 때는 어떻게 하나요?
		 *  어떤 곳에서는 어댑터를 사용하고 어떤 곳에서는 어댑터로 감싸지 않은 인터페이스를 사용하는 이런 경우에는 
		 *  그냥 어댑터를 쓰지 않고 기존 코드를 새로 고치는게 좋지 않나요?
		 * 굳이 그럴 필요는 없다. 두 인터페이스를 모두 지원하는 이중 어댑터를 만들 수도 있다.
		 * 필요한 인터페이스를 둘 다 구현해서 어댑터가 기존 인터페이스와 새로운 인터페이스 역할을 모두 맡을 수 있게 다중 어댑터를 만들면 된다.
		 * 
		 */
	}
	
	/*
	 *  챕터 7 - 2
	 * 
	 * 홈 씨어터(집 영화관) 시스템을 구축한다고 치자.
	 * DVD 플레이어, 프로젝터, 자동 스크린, 팝콘 기계 등등...
	 * 여러 장치들을 사고 연결하고 구축하는데 몇 주를 보냈다.
	 * 이제 영화를 즐겨보자!
	 * DVD를 고르고 편안하게 자리를 잡고 영화를 보려한다.
	 * 아! 빼먹은게 있다. 영화를 보려면 몇가지 일을 해야한다.
	 * 1. 팝콘 기계 키기	2. 팜콘 튀기기 시작		3. 전등 조절
	 * 4. 스크린 내리기		5. 프로젝터 키기 ...............
	 * 12. DVD 플레이어 키기	13. DVD 재생
	 * 
	 * 코드 부분에서 봐보자
	 * popper.on(); popper.pop(); lights.dim(10); ...
	 * dvd.on(); dvd.play(movie);
	 * 
	 * 이럴 때 필요한 것이 퍼사드 패턴이다
	 * HomeTheaterFacade homeTheater = new HomeTheaterFacadeo(amp, tuner, dvd, cd, ... , popper);
	 * homeTheater.watchMovie("범죄와의 전쟁");
	 * homeTheater.endMovie();
	 * 
	 *  퍼사드 패턴(Facade Pattern)
	 * 어떤 서브시스템의 일련의 인터페이스에 대한 통합된 인터페이스를 제공합니다.
	 * 퍼사드에서 고수준 인터페이스를 정의하기 때문에 서브시스템을 더 쉽게 사용할 수 있습니다.
	 * 
	 *  디자인의 원칙
	 * 7. 최소 지식 원칙 - 정말 친한 친구하고만 얘기해라 (객체 사이의 상호작용은 될 수 있으면 아주 가까운 "친구"사이에만 허용하는 것이 좋다.) = 데메테르의 법칙
	 * (시스템을 디자인할 때, 어떤 객체든 그 객체와 상호작용을 하는 클래스의 개수에 주의해야 하며, 
	 * 그런 객체들과 어떤 식으로 상호작용을 하는지에도 주의를 기울여야 한다)
	 * 이 원칙을 잘 따르면 여러 클래스들이 복잡하게 얽혀서 시스템의 한 부분을 변경했을 때 다른 부분까지 줄줄이 고쳐야 되는 상황을 미리 방지할 수 있다.
	 * 
	 * 어떻게 하면 여러 객체하고 인연을 맺는 것을 피할 수 있을까?
	 * 이 원칙에서 여러 가이드라인을 제시한다. 어떤 메소드에서든지 다음 네 종류의 객체의 메소드만을 호출하면 된다.
	 * 1. 객체 자체
	 * 2. 메소드에 매개변수로 전달된 객체
	 * 3. 그 메소드에서 생성하거나 인스턴스를 만든 객체
	 * 4. 그 객체에 속하는 구성요소
	 * LawOfDemeter.java 파일에서 이 주제의 예시를 제시한다.
	 * 
	 * 가이드라인은 가이드라인일 뿐 유념하기만 하자.
	 * 자바에서도 위배되는 것이 있다.
	 * System.out.println();을 생각해 보라.
	 * 
	 */
}
