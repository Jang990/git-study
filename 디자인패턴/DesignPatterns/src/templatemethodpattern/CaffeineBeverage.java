package templatemethodpattern;

public abstract class CaffeineBeverage {
	
	/*	Tea				Coffie
	 *   차를 만드는 방법	커피를 만드는 방법
	 * 1. 물을 끓인다		물을 끓인다
	 * 2. 차를 우려낸다		커피를 우려낸다
	 * 3. 차를 컵에 따른다.	커피를 컵에 따른다
	 * 4. 레몬을 추가한다.	설탕과 우유를 추가한다.
	 * 
	 * 큰 알고리즘은 같다
	 * 물을 끓인다
	 * 우려낸다
	 * 음료를 컵에 따른다
	 * 첨가물을 추가한다.
	 * 
	 * 2, 4번은 약간 다르다.
	 * 2, 4번은 서브클래스에서 구현하도록 만든다.
	 * 그리고 큰 알고리즘을 메소드로 만든다.
	 * final void prepareRecipe() <- 이것이 템플릿 메소드이다.
	 * 서브 클래스에서 알고리즘의 각 단계를 마음대로 건드리지 못하게 final로 선언한다.
	 * 
	 */
	
	final void prepareRecipe() {
		boilWater();
		brew();
		pourInCup();
		/*
		 * 여기서 후크를 추가해 보자
		 * 후크란 추상 클래스에서 선언되는 메소드긴 하지만 기본적인 내용만 구현이 되어있거나 아무 코드도 들어있지 않은 메소드이다.
		 * 사용을 하고자 할때는 서브클래스에서 오버라이드해야 한다. 또는 그냥 놔둘수도 있다. 반드시 구현할 필요는 없다는 소리다.
		 * 예를 들어 여기서 고객이 무엇인가를 추가하고자 하는 'y'라는 문자를 입력받으면 hook가 true를 리턴하도록 서브 클래스에서 구현할 수 있다.
		 */
		if(hook()) {
			addCondiments();
		}
	}
	
	/*
	 *  추상 메소드가 많으면 안좋을 것 같아요. 일일히 구현하기 힘들잖아요...
	 * 맞는말입니다. 템플릿 메소드를 만들때는 꼭 그 점을 생각해두세요. 
	 * 알고리즘의 단계들을 너무 잘게 쪼개지 않는 것도 하나의 방법이 될겁니다. 하지만 큼직하게 나누어 두면
	 * 단점도 있으니 잘 생각해보세요. 유연성이 떨어지거든요.
	 * 그리고 모든 단계가 필수적이지 않다는 점도 기억해 둡시다
	 * 필수적이지 않은 부분은 추상 클래스가 아닌 후크로 구현하면 그 추상 클래스의 서브 클래스를 만들 때 부담이 조금 줄어들겠죠.
	 */
	
	abstract void brew();
	abstract void addCondiments();
	
	void boilWater() {
		System.out.println("물을 끓인다.");
	}
	
	void pourInCup() {
		System.out.println("컵에 따른다.");
	}
	
	boolean hook() {
		return true;
	}
}
